<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Recorder</title>
    <link rel="stylesheet" href="{{ url_for('static', path='/styles.css') }}">
</head>
<body>
    <div class="container">
        <h1>Audio Recorder</h1>
        
        <div class="recorder-container">
            <div id="bubble" class="bubble" role="button" tabindex="0">
                <div class="bubble-icon"></div>
            </div>
            <div id="recordingStatus" class="recording-status"></div>
        </div>

        <div id="recordings" class="recordings-list"></div>
    </div>

    <script>
        class AudioRecorder {
            constructor() {
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.isRecording = false;
                this.bubble = document.getElementById('bubble');
                this.statusElement = document.getElementById('recordingStatus');
                this.recordingsList = document.getElementById('recordings');
                
                this.setupEventListeners();
            }

            setupEventListeners() {
                this.bubble.addEventListener('click', () => this.toggleRecording());
                this.bubble.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.toggleRecording();
                    }
                });
            }

            async startRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.mediaRecorder = new MediaRecorder(stream);
                    this.audioChunks = [];

                    this.mediaRecorder.ondataavailable = (event) => {
                        this.audioChunks.push(event.data);
                    };

                    this.mediaRecorder.onstop = () => this.handleRecordingStop();

                    this.mediaRecorder.start();
                    this.isRecording = true;
                    this.updateUI(true);
                    this.startVisualization(stream);
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    this.statusElement.textContent = 'Error: Could not access microphone';
                }
            }

            stopRecording() {
                if (this.mediaRecorder) {
                    this.mediaRecorder.stop();
                    this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                    this.isRecording = false;
                    this.updateUI(false);
                }
            }

            async handleRecordingStop() {
                const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                const formData = new FormData();
                formData.append('audio', audioBlob);

                try {
                    const response = await fetch('/upload-audio', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (response.ok) {
                        this.addRecordingToList(audioBlob);
                    } else {
                        console.error('Upload failed');
                    }
                } catch (error) {
                    console.error('Error uploading:', error);
                }
            }

            addRecordingToList(blob) {
                const recordingElement = document.createElement('div');
                recordingElement.className = 'recording-item';

                const audio = document.createElement('audio');
                audio.controls = true;
                audio.src = URL.createObjectURL(blob);

                recordingElement.appendChild(audio);
                this.recordingsList.prepend(recordingElement);
            }

            updateUI(isRecording) {
                this.bubble.classList.toggle('recording', isRecording);
                this.statusElement.textContent = isRecording ? 'Recording...' : '';
            }

            startVisualization(stream) {
                const audioContext = new AudioContext();
                const source = audioContext.createMediaStreamSource(stream);
                const analyser = audioContext.createAnalyser();
                
                source.connect(analyser);
                analyser.fftSize = 256;
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const animate = () => {
                    if (!this.isRecording) {
                        this.bubble.style.transform = 'scale(1)';
                        return;
                    }

                    analyser.getByteFrequencyData(dataArray);
                    const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                    const scale = 1 + (average / 256) * 0.5;
                    
                    this.bubble.style.transform = `scale(${scale})`;
                    requestAnimationFrame(animate);
                };

                animate();
            }

            toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }
        }

        // Initialize the recorder when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new AudioRecorder();
        });
    </script>
</body>
</html>